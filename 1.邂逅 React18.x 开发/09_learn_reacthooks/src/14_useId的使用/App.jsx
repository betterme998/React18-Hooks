// useId 在SSR同构应用中使用，SPA应用（单页面复应用）中不使用
import React, { memo, useId, useState } from "react";

const App = memo(() => {
  console.log(React.useId());
  const [count, setCount] = useState(0);

  // 不管渲染几次
  // 生成一个唯一的id，这个id在服务器和客户端会保持一致
  const id = useId();
  console.log(id);

  return (
    <div>
      <button onClick={(e) => setCount(count + 1)}>count+1:{count}</button>

      <label htmlFor={id}>
        用户名：
        <input id={id} type="text" />
      </label>
    </div>
  );
});

export default App;

// node =>Vue/React服务器端渲染APl=>nuxt/next
// 要想学号nuxt/next,需要先学会node和vue/react

//SPA: 单页面富应用的两个问题
//1.首屏的渲染速度
// 2.不利于SEO优化

// 1.单页面富应用如何在浏览器中渲染出来的？
// 浏览器做了哪些操作呢？
// 浏览器会根据域名或者ip地址找到对应的服务器，去服务器里请求对应的文件（一个文件）index.html
// 思考一下一个SPA页面，index.html里面有东西吗？
// 基本上是没有的
// 自己搭建webpack的环境 => index.html =>body里面什么都没有，只有一个div#app

// SEO优化：搜索引擎优化
// 百度，它有很多台服务器，24小时不关机的情况下，不断去网络上面爬取数据
// 它去爬取就是把index.html下载下来，如果爬其他东西太消耗性能
// 所以它在收录网站的时候，最主要收入的index.html里面配置的meta配置，或者body里的内容
// 收录到数据库里面后，会根据关键字匹配，当用户百度一下搜索关键字的时候
// 因为收录的信息很少，所以网站排名可能非常靠后，用户就不可能打开你的网站，不会给网站带来流量
// 所以SPA页面非常不利于SEO优化
// 如果可以把网站所以内容爬下来，那么在收录的时候网站就会比较靠前
// 因为我们是SPA页面，所以百度爬取到的内容会很少，在收录的时候匹配度很低，排名就靠后

// 首屏的渲染速度
// 早期的SSR的页面：JSP，它是在服务器里面把整个网站渲染好，当我们去请求的时候是把整个网页请求下来的
// 拿到完整的页面后，首先从爬虫的角度，可以爬更多的数据，匹配度更高，有利于SEO优化
// 因为直接下载下来就是一个完整的页面，意味着浏览器直接渲染整个网站就行了
// 那SPA下载下来的就是一个空的index.html
// 在index.html页面中有script src = "xxx.js"
// 我们需要从服务器里再下载js文件，如果没有做分包处理，js文件会非常大，意味着下载时间长
// 下载完后,浏览器还要执行xxx.js文件代码，执行完后，再去渲染页面
// 不过我们可以借助于Node来帮助我们执行JavaScript代码，提前完成页面的结构;

//官方的解释:useld 是一个用于生成横跨服务端和客户端的稳定的唯一 ID 的同时避免 hydration 不匹配的 hook。
//这里有一个词叫hydration，要想理解这个词，我们需要理解一些服务器端渲染(SSR)的概念。

// SSR同构应用
// ■ 什么是同构?
// 口 一套代码既可以在服务端运行又可以在客户端运行，这就是同构应用。
// 就是anguar/react/vue 的一套代码，既可以在服务端运行，也可以在客户端运行

// 服务端运行：这套代码可以交给node来执行，但是不是直接执行，node需要借助anguar/react/vue提供的一些ssr的api，在node端运行一遍
// 运行最终的结果就是输出index.html页面结构，直接交给浏览器运行

// 浏览器运行：输出的也是index.html结构

// 问题：那我们在node端允许了一遍，那为什么要在浏览器端再运行一遍呢？
// 答案：直接从nede输出的结构，相当于一串字符串，里面没有绑定任何js的东西，比如绑定事件。
// 所以node端输出的最终目的主要是：展示
// 之后的操作没有做
// 所以浏览器端需要再运行一遍，把交互的东西注入进去
// 注入的过程叫做：hydrate

//■ 同构是一种SSR的形态，是现代SSR的一种表现形式。
//口 当用户发出请求时，先在服务器通过SSR渲染出首页的内容。
//口 但是对应的代码同样可以在客户端被执行。
//口 执行的目的包括事件绑定等以及其他页面切换时也可以在客户端被渲染

// Hydration
// ■ 什么是Hydration?这里我引入vite-plugin-ssr插件的官方解释。
// ■ 在进行 SSR 时，我们的页面会呈现为 HTML。
//  口但仅 HTML不足以使页面具有交互性。例如，浏览器端」avascript 为零的页面不能是交互式的(没有Javascript 事件处理程序来响应用户操作，例如单击按钮)
//  口为了使我们的页面具有交互性，除了在 Node.js 中将页面呈现为 HTML之外，我们的U框架(vue/React..)还在浏览器中加载和呈现页面。(它创建页面的内部表示，然后将内部表示映射到我们在 Node.js 中呈现的 HTML的 DOM 元素。)
// ■ 这个过程称为hydration

// useld的作用
// 我们再来看一遍:useld 是一个用于生成横跨服务端和客户端的稳定的唯一ID 的同时避免 hydration 不匹配的 hook。
